// Code generated by gen; DO NOT EDIT.
package config

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"graphql-project/core"
	"net/netip"
	"os"
	"strings"
	"time"
)

type flagOptions struct {
	bindAddr             string
	port                 uint
	jwtSecret            string
	jwtExpiration        time.Duration
	jwtRefreshExpiration time.Duration
	dbHost               string
	dbPort               uint
	dbUser               string
	dbPassword           string
	dbName               string
	dbTimeout            time.Duration
	dbMaxConnections     uint
	dbMigrate            bool
	queryComplexity      int
	logLevel             string
}

type errHelp string

func (err errHelp) Unwrap() error {
	return flag.ErrHelp
}

func (err errHelp) Error() string {
	return string(err)
}

type Options interface {
	Get(name string) core.Any
}

type environment struct{}

type dotEnv map[string]string

type allOptions []Options

func (e environment) Get(name string) core.Any {
	if s, ok := os.LookupEnv(name); !ok {
		return core.Any{}
	} else {
		return core.NewAny(s)
	}
}

func EnvOptions() Options {
	return environment{}
}

func loadLines(fileName string) (lines []string, err error) {
	lines = make([]string, 0, 128)
	var file *os.File
	file, err = os.OpenFile(fileName, os.O_RDONLY, 0)
	if err != nil {
		return
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	err = scanner.Err()
	file.Close()
	return
}

func DotEnvOptions(files []string) (Options, error) {
	var values dotEnv = make(map[string]string)
	for _, fileName := range files {
		lines, err := loadLines(fileName)
		if err != nil {
			return nil, err
		}
		for _, str := range lines {
			if core.StartWith(str, '#') {
				continue
			}
			if i := strings.IndexByte(str, '='); i > 0 {
				param := strings.TrimSpace(str[:i])
				if param != "" {
					value := str[i+1:]
					if i := strings.IndexByte(value, '#'); i >= 0 {
						value = value[:i]
					}
					value = core.TrimQuotes(strings.TrimSpace(value))
					if value != "" {
						values[param] = value
					}
				}
			}
		}
	}
	return values, nil
}

func (d dotEnv) Get(name string) core.Any {
	if s, ok := d[name]; !ok {
		return core.Any{}
	} else {
		return core.NewAny(s)
	}
}

func (flagOpts flagOptions) Get(name string) core.Any {
	switch name {
	case "ADDRESS":
		return core.NewAny(flagOpts.bindAddr)
	case "PORT":
		return core.NewAny(flagOpts.port)
	case "JWT_SECRET":
		return core.NewAny(flagOpts.jwtSecret)
	case "JWT_EXPIRATION":
		return core.NewAny(flagOpts.jwtExpiration)
	case "JWT_REFRESH_EXPIRATION":
		return core.NewAny(flagOpts.jwtRefreshExpiration)
	case "DB_HOST":
		return core.NewAny(flagOpts.dbHost)
	case "DB_PORT":
		return core.NewAny(flagOpts.dbPort)
	case "DB_USER":
		return core.NewAny(flagOpts.dbUser)
	case "DB_PASSWORD":
		return core.NewAny(flagOpts.dbPassword)
	case "DB_NAME":
		return core.NewAny(flagOpts.dbName)
	case "DB_TIMEOUT":
		return core.NewAny(flagOpts.dbTimeout)
	case "DB_CONNECTIONS":
		return core.NewAny(flagOpts.dbMaxConnections)
	case "DB_MIGRATE":
		return core.NewAny(flagOpts.dbMigrate)
	case "GQL_QUERY_COMPLEXITY":
		return core.NewAny(flagOpts.queryComplexity)
	case "LOG_LEVEL":
		return core.NewAny(flagOpts.logLevel)
	default:
		panic(fmt.Sprintf("unknown flag `%s`", name))
	}
}

func (options allOptions) Get(name string) core.Any {
	for _, o := range options {
		if o != nil {
			if v := o.Get(name); !v.IsEmpty() {
				return v
			}
		}
	}
	return core.Any{}
}

func FlagOptions(args []string) (Options, error) {
	flags := flag.NewFlagSet(args[0], flag.ContinueOnError)
	var buffer bytes.Buffer
	flags.SetOutput(&buffer)

	var options flagOptions
	flags.StringVar(&options.bindAddr, "bind-addr", "0.0.0.0", "bind host address")
	flags.UintVar(&options.port, "port", 8080, "listen port")
	flags.StringVar(&options.jwtSecret, "jwt-secret", "", "base64 encoded JWT secret")
	flags.DurationVar(&options.jwtExpiration, "jwt-expiration", 0, "JWT access expiration time: 1h20m30s")
	flags.DurationVar(&options.jwtRefreshExpiration, "jwt-refresh-expiration", 0, "JWT refresh expiration time: 1h20m30s")
	flags.StringVar(&options.dbHost, "db-host", "localhost", "database host address")
	flags.UintVar(&options.dbPort, "db-port", 5432, "database port")
	flags.StringVar(&options.dbUser, "db-user", "postgres", "database user")
	flags.StringVar(&options.dbPassword, "db-password", "", "database user password")
	flags.StringVar(&options.dbName, "db-name", "", "database name")
	flags.DurationVar(&options.dbTimeout, "db-timeout", 5000000000, "database connection timeout")
	flags.UintVar(&options.dbMaxConnections, "db-connections", 0, "max database connections")
	flags.BoolVar(&options.dbMigrate, "db-migrate", true, "Apply database migrations")
	flags.IntVar(&options.queryComplexity, "query-complexity", 2000, "GQL query max complexity")
	flags.StringVar(&options.logLevel, "log-level", "info", "log level: debug|info|warn|error|fatal|trace|disable")
	err := flags.Parse(args[1:])
	if err != nil {
		if err == flag.ErrHelp {
			return nil, errHelp(buffer.String())
		}
		return nil, err
	}
	return options, nil
}

func newOptions(cfgOpts cfgOptions) (options Options, err error) {
	var flagOptions Options
	if cfgOpts.useFlags {
		flagOptions, err = FlagOptions(os.Args)
		if err != nil {
			return
		}
	}
	dotEnvOptions, err := DotEnvOptions(cfgOpts.files)
	if err != nil {
		if !errors.Is(err, os.ErrNotExist) {
			return
		}
	}
	var allOpts allOptions = []Options{EnvOptions(), dotEnvOptions, flagOptions}
	options = allOpts
	return
}

func (config *Config) BindAddr() netip.Addr {
	return config.bindAddr
}

func (config *Config) Port() uint16 {
	return config.port
}

func (config *Config) JwtSecret() []byte {
	return config.jwtSecret
}

func (config *Config) JwtExpiration() time.Duration {
	return config.jwtExpiration
}

func (config *Config) JwtRefreshExpiration() time.Duration {
	return config.jwtRefreshExpiration
}

func (config *Config) DbHost() netip.Addr {
	return config.dbHost
}

func (config *Config) DbPort() uint16 {
	return config.dbPort
}

func (config *Config) DbUser() string {
	return config.dbUser
}

func (config *Config) DbPassword() string {
	return config.dbPassword
}

func (config *Config) DbName() string {
	return config.dbName
}

func (config *Config) DbTimeout() time.Duration {
	return config.dbTimeout
}

func (config *Config) DbMaxConnections() uint32 {
	return config.dbMaxConnections
}

func (config *Config) DbMigrate() bool {
	return config.dbMigrate
}

func (config *Config) QueryComplexity() int {
	return config.queryComplexity
}

func (config *Config) LogLevel() string {
	return config.logLevel
}

type cfgOptions struct {
	files    []string
	useFlags bool
}

func DisableFlags() func(*cfgOptions) {
	return func(cfgOpts *cfgOptions) {
		cfgOpts.useFlags = false
	}
}

func Files(files ...string) func(*cfgOptions) {
	return func(cfgOpts *cfgOptions) {
		cfgOpts.files = files
	}
}

func (config *Config) Load(opts ...func(*cfgOptions)) (err error) {
	cfgOpts := cfgOptions{useFlags: true, files: []string{".env"}}
	for _, opt := range opts {
		opt(&cfgOpts)
	}
	options, err := newOptions(cfgOpts)
	if err != nil {
		if !errors.Is(err, os.ErrNotExist) {
			return
		}
	}
	var option core.Any
	option = options.Get("ADDRESS")
	if option.IsEmpty() {
		err = errors.New("bindAddr: no value")
		return
	}
	config.bindAddr, err = option.Addr()
	if err != nil {
		err = fmt.Errorf("bindAddr: %w", err)
		return
	}
	option = options.Get("PORT")
	if option.IsEmpty() {
		err = errors.New("port: no value")
		return
	}
	config.port, err = option.Uint16()
	if err != nil {
		err = fmt.Errorf("port: %w", err)
		return
	}
	option = options.Get("JWT_SECRET")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("jwtSecret: no value")
		return
	}
	config.jwtSecret, err = option.Bytes()
	if err != nil {
		err = fmt.Errorf("jwtSecret: %w", err)
		return
	}
	option = options.Get("JWT_EXPIRATION")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("jwtExpiration: no value")
		return
	}
	config.jwtExpiration, err = option.Duration()
	if err != nil {
		err = fmt.Errorf("jwtExpiration: %w", err)
		return
	}
	option = options.Get("JWT_REFRESH_EXPIRATION")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("jwtRefreshExpiration: no value")
		return
	}
	config.jwtRefreshExpiration, err = option.Duration()
	if err != nil {
		err = fmt.Errorf("jwtRefreshExpiration: %w", err)
		return
	}
	option = options.Get("DB_HOST")
	if option.IsEmpty() {
		err = errors.New("dbHost: no value")
		return
	}
	config.dbHost, err = option.Addr()
	if err != nil {
		err = fmt.Errorf("dbHost: %w", err)
		return
	}
	option = options.Get("DB_PORT")
	if option.IsEmpty() {
		err = errors.New("dbPort: no value")
		return
	}
	config.dbPort, err = option.Uint16()
	if err != nil {
		err = fmt.Errorf("dbPort: %w", err)
		return
	}
	option = options.Get("DB_USER")
	if option.IsEmpty() {
		err = errors.New("dbUser: no value")
		return
	}
	config.dbUser, err = option.String()
	if err != nil {
		err = fmt.Errorf("dbUser: %w", err)
		return
	}
	option = options.Get("DB_PASSWORD")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("dbPassword: no value")
		return
	}
	config.dbPassword, err = option.String()
	if err != nil {
		err = fmt.Errorf("dbPassword: %w", err)
		return
	}
	option = options.Get("DB_NAME")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("dbName: no value")
		return
	}
	config.dbName, err = option.String()
	if err != nil {
		err = fmt.Errorf("dbName: %w", err)
		return
	}
	option = options.Get("DB_TIMEOUT")
	if option.IsEmpty() {
		err = errors.New("dbTimeout: no value")
		return
	}
	config.dbTimeout, err = option.Duration()
	if err != nil {
		err = fmt.Errorf("dbTimeout: %w", err)
		return
	}
	option = options.Get("DB_CONNECTIONS")
	if option.IsEmpty() || option.IsDefault() {
		err = errors.New("dbMaxConnections: no value")
		return
	}
	config.dbMaxConnections, err = option.Uint32()
	if err != nil {
		err = fmt.Errorf("dbMaxConnections: %w", err)
		return
	}
	option = options.Get("DB_MIGRATE")
	if option.IsEmpty() {
		err = errors.New("dbMigrate: no value")
		return
	}
	config.dbMigrate, err = option.Bool()
	if err != nil {
		err = fmt.Errorf("dbMigrate: %w", err)
		return
	}
	option = options.Get("GQL_QUERY_COMPLEXITY")
	if option.IsEmpty() {
		err = errors.New("queryComplexity: no value")
		return
	}
	config.queryComplexity, err = option.Int()
	if err != nil {
		err = fmt.Errorf("queryComplexity: %w", err)
		return
	}
	option = options.Get("LOG_LEVEL")
	if option.IsEmpty() {
		err = errors.New("logLevel: no value")
		return
	}
	config.logLevel, err = option.String()
	if err != nil {
		err = fmt.Errorf("logLevel: %w", err)
		return
	}
	return
}
