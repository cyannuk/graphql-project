// Code generated by gen; DO NOT EDIT.
package model

import (
	"graphql-project/interface/model"

	"github.com/jackc/pgx/v5"
)

func (order *Order) Table() string {
	return "orders"
}

func (order *Order) Field(property string) string {
	switch property {
	case "id":
		return "id"
	case "createdAt":
		return "createdAt"
	case "user":
		return "userId"
	case "product":
		return "productId"
	case "discount":
		return "discount"
	case "quantity":
		return "quantity"
	case "subtotal":
		return "subtotal"
	case "tax":
		return "tax"
	case "total":
		return "total"
	case "deletedAt":
		return "deletedAt"
	default:
		return ""
	}
}

func (order *Order) Fields() []string {
	return []string{
		"id", "createdAt", "userId", "productId", "discount", "quantity", "subtotal", "tax", "total", "deletedAt",
	}
}

func (order *Order) Identity() string {
	return "id"
}

func (order *Order) ScanRow(rows pgx.Rows) error {
	values := rows.RawValues()
	for i, fieldDesc := range rows.FieldDescriptions() {
		v := value(values[i])
		switch fieldDesc.Name {
		case "id":
			order.ID = v.Int64()
		case "createdAt":
			order.CreatedAt = v.Time()
		case "userId":
			order.UserId = v.Int64()
		case "productId":
			order.ProductId = v.Int64()
		case "discount":
			order.Discount = v.Float64()
		case "quantity":
			order.Quantity = v.Int32()
		case "subtotal":
			order.Subtotal = v.Float64()
		case "tax":
			order.Tax = v.Float64()
		case "total":
			order.Total = v.Float64()
		case "deletedAt":
			if v != nil {
				n := v.Time()
				order.DeletedAt = &n
			} else {
				order.DeletedAt = nil
			}
		}
	}
	return nil
}

type Orders []Order
type OrderRefs []*Order

func (Orders *Orders) NewEntity() model.Entity {
	return &Order{}
}

func (Orders *Orders) Add(entity model.Entity) {
	order := entity.(*Order)
	*Orders = append(*Orders, *order)
}

func (Orders *OrderRefs) NewEntity() model.Entity {
	return &Order{}
}

func (Orders *OrderRefs) Add(entity model.Entity) {
	order := *entity.(*Order)
	*Orders = append(*Orders, &order)
}

func (order *Order) getUserId() any {
	return (order.UserId)
}

func (order *Order) getProductId() any {
	return (order.ProductId)
}

func (order *Order) getDiscount() any {
	return (order.Discount)
}

func (order *Order) getQuantity() any {
	return (order.Quantity)
}

func (order *Order) getSubtotal() any {
	return (order.Subtotal)
}

func (order *Order) getTax() any {
	return (order.Tax)
}

func (order *Order) getTotal() any {
	return (order.Total)
}

func (order *Order) NewEntity() model.Entity {
	return &Order{}
}

func (order *Order) EnumerateFields(f func(name string, value any)) {
	f("userId", order.getUserId())
	f("productId", order.getProductId())
	f("discount", order.getDiscount())
	f("quantity", order.getQuantity())
	f("subtotal", order.getSubtotal())
	f("tax", order.getTax())
	f("total", order.getTotal())
}

type OrderInput struct {
	UserId    NullBigInt
	ProductId NullBigInt
	Discount  NullDouble
	Quantity  NullInt
	Subtotal  NullDouble
	Tax       NullDouble
	Total     NullDouble
}

func (order *OrderInput) NewEntity() model.Entity {
	return &Order{}
}

func (order *OrderInput) EnumerateFields(f func(name string, value any)) {
	if order.UserId.State != None {
		f("userId", order.UserId)
	}
	if order.ProductId.State != None {
		f("productId", order.ProductId)
	}
	if order.Discount.State != None {
		f("discount", order.Discount)
	}
	if order.Quantity.State != None {
		f("quantity", order.Quantity)
	}
	if order.Subtotal.State != None {
		f("subtotal", order.Subtotal)
	}
	if order.Tax.State != None {
		f("tax", order.Tax)
	}
	if order.Total.State != None {
		f("total", order.Total)
	}
}
