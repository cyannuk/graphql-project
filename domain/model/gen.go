//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/iancoleman/strcase"
)

func main() {
	if err := parsePackage(os.Getenv("GOPACKAGE"), os.Getenv("GOFILE")); err != nil {
		log.Fatal(err)
	}
}

func findTypes(file *ast.File) map[string]*ast.StructType {
	types := make(map[string]*ast.StructType)
	ast.Inspect(file, func(node ast.Node) bool {
		if typeSpec, ok := node.(*ast.TypeSpec); ok {
			if t, ok := typeSpec.Type.(*ast.StructType); ok {
				types[typeSpec.Name.Name] = t
				return false
			}
		}
		return true
	})
	return types
}

func parsePackage(pkgName string, srcFile string) error {

	packages, err := parser.ParseDir(token.NewFileSet(), ".", nil, 0)
	if err != nil {
		return err
	}

	for _, pkg := range packages {
		if pkg.Name == pkgName {
			for fileName, pkgFile := range pkg.Files {
				if fileName == srcFile {
					types := findTypes(pkgFile)
					if len(types) == 0 {
						continue
					}

					file := NewFilePathName(pkgName, pkg.Name)
					file.PackageComment("Code generated by gen. DO NOT EDIT.")

					for typeName, structType := range types {
						generate(file, typeName, structType)
					}

					writer, err := os.OpenFile(strings.Replace(fileName, ".go", "_gen.go", 1), os.O_CREATE|os.O_WRONLY, 0644)
					if err != nil {
						return err
					}
					_ = writer.Truncate(0)
					err = file.Render(writer)
					if err != nil {
						return err
					}
				}
			}
		}
	}

	return nil
}

func generate(file *File, typeName string, structType *ast.StructType) {

	generateCloneFunc(file, structType, typeName)
	generateFieldFunc(file, structType, typeName)
	generateFieldsFunc(file, structType, typeName)
	generateIdentityFunc(file, structType, typeName)
}

func generateCloneFunc(file *File, t *ast.StructType, typeName string) {
	objectId := strings.ToLower(typeName[:1])
	file.Func().Params(
		Id(objectId).Op("*").Id(typeName),
	).Id("Clone").Params().Id(typeName).BlockFunc(func(group *Group) {
		group.Return().Id(typeName).Values(DictFunc(func(d Dict) {
			for _, field := range t.Fields.List {
				fieldName := field.Names[0].Name
				d[Id(fieldName)] = Id(objectId).Dot(fieldName)
			}
		}))
	}).Line()
}

func generateFieldFunc(file *File, t *ast.StructType, typeName string) {
	objectId := strings.ToLower(typeName[:1])
	file.Func().Params(
		Id(objectId).Op("*").Id(typeName),
	).Id("Field").Params(Id("name").String()).Parens(List(String(), Any())).BlockFunc(func(group *Group) {
		group.Switch(Id("name")).BlockFunc(func(g *Group) {
			for _, field := range t.Fields.List {
				fieldName := field.Names[0].Name
				name := strcase.ToLowerCamel(fieldName)
				if strings.HasSuffix(name, "Id") {
					g.Case(Lit(name[:len(name)-2])).Block(Return().List(Lit(name), Op("&").Id(objectId).Dot(fieldName)))
				}
				g.Case(Lit(name)).Block(Return().List(Lit(name), Op("&").Id(objectId).Dot(fieldName)))
			}
			g.Default().Block(Return().List(Lit(""), Nil()))
		})
	}).Line()
}

func generateFieldsFunc(file *File, t *ast.StructType, typeName string) {
	var sb strings.Builder
	sb.Grow(256)
	for i, field := range t.Fields.List {
		if i > 0 {
			sb.WriteByte(',')
		}
		sb.WriteByte('"')
		sb.WriteString(strcase.ToLowerCamel(field.Names[0].Name))
		sb.WriteByte('"')
	}
	objectId := strings.ToLower(typeName[:1])
	file.Func().Params(
		Id(objectId).Op("*").Id(typeName),
	).Id("Fields").Params().Parens(List(String(), Index().Any())).
		Block(
			Return().List(Lit(sb.String()), Index().Any().ValuesFunc(func(g *Group) {
				for _, field := range t.Fields.List {
					g.Op("&").Id(objectId).Dot(field.Names[0].Name)
				}
			})),
		).Line()
}

func generateIdentityFunc(file *File, t *ast.StructType, typeName string) {
	var fieldName string
	for _, field := range t.Fields.List {
		fieldName = field.Names[0].Name
		if strings.ToLower(fieldName) == "id" {
			break
		}
		fieldName = ""
	}
	if fieldName != "" {
		objectId := strings.ToLower(typeName[:1])
		file.Func().Params(
			Id(objectId).Op("*").Id(typeName),
		).Id("Identity").Params().Parens(List(String(), Any())).
			Block(
				Return().List(Lit("id"), Op("&").Id(objectId).Dot(fieldName)),
			)
	} else {
		fmt.Printf("WARNING. No %s.ID field\n", typeName)
	}
}
