// Code generated by gen; DO NOT EDIT.
package model

import (
	"graphql-project/interface/model"

	"github.com/jackc/pgx/v5"
)

func (product *Product) Table() string {
	return "products"
}

func (product *Product) Field(property string) string {
	switch property {
	case "id":
		return "id"
	case "createdAt":
		return "createdAt"
	case "category":
		return "category"
	case "ean":
		return "ean"
	case "price":
		return "price"
	case "quantity":
		return "quantity"
	case "rating":
		return "rating"
	case "name":
		return "name"
	case "vendor":
		return "vendor"
	case "deletedAt":
		return "deletedAt"
	default:
		return ""
	}
}

func (product *Product) Fields() []string {
	return []string{
		"id", "createdAt", "category", "ean", "price", "quantity", "rating", "name", "vendor", "deletedAt",
	}
}

func (product *Product) Identity() string {
	return "id"
}

func (product *Product) ScanRow(rows pgx.Rows) error {
	values := rows.RawValues()
	for i, fieldDesc := range rows.FieldDescriptions() {
		v := value(values[i])
		switch fieldDesc.Name {
		case "id":
			product.ID = v.Int64()
		case "createdAt":
			product.CreatedAt = v.Time()
		case "category":
			product.Category = v.String()
		case "ean":
			product.Ean = v.String()
		case "price":
			product.Price = v.Float64()
		case "quantity":
			product.Quantity = v.Int32()
		case "rating":
			product.Rating = v.Float64()
		case "name":
			product.Name = v.String()
		case "vendor":
			product.Vendor = v.String()
		case "deletedAt":
			if v != nil {
				n := v.Time()
				product.DeletedAt = &n
			} else {
				product.DeletedAt = nil
			}
		}
	}
	return nil
}

type Products []Product
type ProductRefs []*Product

func (Products *Products) NewEntity() model.Entity {
	return &Product{}
}

func (Products *Products) Add(entity model.Entity) {
	product := entity.(*Product)
	*Products = append(*Products, *product)
}

func (Products *ProductRefs) NewEntity() model.Entity {
	return &Product{}
}

func (Products *ProductRefs) Add(entity model.Entity) {
	product := *entity.(*Product)
	*Products = append(*Products, &product)
}

func (product *Product) getCategory() any {
	return (product.Category)
}

func (product *Product) getEan() any {
	return (product.Ean)
}

func (product *Product) getPrice() any {
	return (product.Price)
}

func (product *Product) getQuantity() any {
	return (product.Quantity)
}

func (product *Product) getRating() any {
	return (product.Rating)
}

func (product *Product) getName() any {
	return (product.Name)
}

func (product *Product) getVendor() any {
	return (product.Vendor)
}

func (product *Product) NewEntity() model.Entity {
	return &Product{}
}

func (product *Product) EnumerateFields(f func(name string, value any)) {
	f("category", product.getCategory())
	f("ean", product.getEan())
	f("price", product.getPrice())
	f("quantity", product.getQuantity())
	f("rating", product.getRating())
	f("name", product.getName())
	f("vendor", product.getVendor())
}

type ProductInput struct {
	Category NullString
	Ean      NullString
	Price    NullDouble
	Quantity NullInt
	Rating   NullDouble
	Name     NullString
	Vendor   NullString
}

func (product *ProductInput) NewEntity() model.Entity {
	return &Product{}
}

func (product *ProductInput) EnumerateFields(f func(name string, value any)) {
	if product.Category.State != None {
		f("category", product.Category)
	}
	if product.Ean.State != None {
		f("ean", product.Ean)
	}
	if product.Price.State != None {
		f("price", product.Price)
	}
	if product.Quantity.State != None {
		f("quantity", product.Quantity)
	}
	if product.Rating.State != None {
		f("rating", product.Rating)
	}
	if product.Name.State != None {
		f("name", product.Name)
	}
	if product.Vendor.State != None {
		f("vendor", product.Vendor)
	}
}
