package main

import (
	"fmt"
	"io"
	"net/http"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/99designs/gqlgen/graphql/executor"
	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/adaptor"
	"github.com/rs/zerolog/log"
	"github.com/vektah/gqlparser/v2/gqlerror"

	"graphql-pro/domain/repository"
	"graphql-pro/graph"
	"graphql-pro/graph/generated"
)

type Application struct {
	dataSource  repository.DataSource
	app         *fiber.App
	gqlExecutor *executor.Executor
}

func (application *Application) Shutdown() error {
	if err := application.dataSource.Close(); err != nil {
		return err
	}
	if application.app != nil {
		if err := application.app.Shutdown(); err != nil {
			return err
		}
		application.app = nil
	}
	return nil
}

func (application *Application) Default(_ *fiber.Ctx) error {
	return nil
}

func (application *Application) Start(bindAddr string) error {
	return application.app.Listen(bindAddr)
}

//func sendError(ctx *fiber.Ctx, code int, errors ...*gqlerror.Error) {
//	ctx.Response().SetStatusCode(code)
//	if b, err := json.Marshal(&graphql.Response{Errors: errors}); err != nil {
//		log.Error().Err(err).Msg("send error")
//	} else {
//		if _, err := ctx.Response().BodyWriter().Write(b); err != nil {
//			log.Error().Err(err).Msg("send error")
//		}
//	}
//}

func statusFor(errs gqlerror.List) int {
	switch errcode.GetErrorKind(errs) {
	case errcode.KindProtocol:
		return http.StatusUnprocessableEntity
	default:
		return http.StatusOK
	}
}

func getRequestBody(r *http.Request) (string, error) {
	if r == nil || r.Body == nil {
		return "", nil
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		return "", fmt.Errorf("unable to get Request Body %w", err)
	}
	return string(body), nil
}

func Do(ctx0 *fiber.Ctx, r *http.Request, exec graphql.GraphExecutor) error {
	ctx := r.Context()
	//?? writeHeaders(w, h.ResponseHeaders)
	now := graphql.Now()
	params := graphql.RawParams{Headers: r.Header, ReadTime: graphql.TraceTiming{Start: now, End: now}}

	//bodyString, err := getRequestBody(r)
	//if err != nil {
	//	gqlErr := gqlerror.Errorf("could not get json request body: %+v", err)
	//	return ctx0.JSON(exec.DispatchError(ctx, gqlerror.List{gqlErr}))
	//}

	decoder := json.NewDecoder(r.Body)
	decoder.UseNumber()

	// bodyReader := io.NopCloser(strings.NewReader(bodyString))
	if err := decoder.Decode(&params); err != nil {
		ctx0.Response().SetStatusCode(http.StatusBadRequest)
		b, _ := io.ReadAll(r.Body)
		gqlErr := gqlerror.Errorf("json request body could not be decoded: %+v body:%s", err, string(b))
		return ctx0.JSON(exec.DispatchError(ctx, gqlerror.List{gqlErr}))
	}

	if rc, err := exec.CreateOperationContext(ctx, &params); err != nil {
		ctx0.Response().SetStatusCode(statusFor(err))
		return ctx0.JSON(exec.DispatchError(graphql.WithOperationContext(ctx, rc), err))
	} else {
		responses, ctx := exec.DispatchOperation(ctx, rc)
		return ctx0.JSON(responses(ctx))
	}
}

func (application *Application) Graphql(ctx *fiber.Ctx) error {
	if request, err := adaptor.ConvertRequest(ctx, true); err != nil {
		log.Error().Err(err).Str("RequestURI", request.RequestURI).Msg("cannot parse")
		return fiber.ErrInternalServerError
	} else {
		defer func() {
			if err := recover(); err != nil {
				err := application.gqlExecutor.PresentRecoveredError(ctx.Context(), err)
				gqlErr, _ := err.(*gqlerror.Error)
				resp := graphql.Response{Errors: []*gqlerror.Error{gqlErr}}
				if b, err := json.Marshal(&resp); err != nil {
					log.Error().Err(err).Msg("send entity error")
				} else {
					ctx.Response().SetStatusCode(http.StatusUnprocessableEntity)
					if _, err := ctx.Response().BodyWriter().Write(b); err != nil {
						log.Error().Err(err).Msg("send entity error")
					}
				}
			}
		}()

		return Do(ctx, request.WithContext(graphql.StartOperationTrace(request.Context())), application.gqlExecutor)
	}
}

func NewApplication(connectionString string) (Application, error) {
	dataSource, err := repository.NewDataSource(connectionString)
	if err != nil {
		return Application{}, err
	}

	gqlExecutor := executor.New(generated.NewExecutableSchema(generated.Config{Resolvers: &graph.Resolver{UsersRepo: repository.NewUserRepository(dataSource)}}))

	application := Application{dataSource, fiber.New(fiber.Config{JSONEncoder: json.Marshal, JSONDecoder: json.Unmarshal, DisableKeepalive: true, DisableStartupMessage: true, DisableDefaultDate: true}), gqlExecutor}

	application.app.Get("/", application.Default)
	application.app.Post("/graphql", application.Graphql)

	return application, nil
}
